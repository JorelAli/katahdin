module Fl
{

    ///////////////////////
    // BASIC EXPRESSIONS //
    ///////////////////////

    class Expression;
    
    class NumberExpression : Expression
    {
        // Very stupid, but hilariously stupid.
        // "Allows" running Fortran code from Fl

        field numericalValue;

        pattern
        {
            number:Number
        }

        method Parsed()
        {
            this.numericalValue = this.number.Value;
        }
        
        method Get()
        {
            return this.numericalValue;
        }

        method Set(value)
        {
            this.numericalValue = value;
        }
    }

    class StringExpression : Expression
    {
        pattern
        {
            string:String
        }
        
        method Get()
        {
            return this.string.Text;
        }
    }

    /////////////////////
    // BASIC OPERATORS //
    /////////////////////

    class MultiplicativeExpression : Expression;
    
    class MulExpression : MultiplicativeExpression
    {
        pattern
        {
            option leftRecursive;
            a:Expression "*" b:Expression
        }
        
        method Get()
        {
            return this.a.Get...() * this.b.Get...();
        }
    }
    
    class DivExpression : MultiplicativeExpression
    {
        pattern
        {
            option leftRecursive;
            a:Expression "/" b:Expression
        }
        
        method Get()
        {
            return this.a.Get...() / this.b.Get...();
        }
    }
    
    precedence MultiplicativeExpression < CallExpression;
    
    class AdditiveExpression : Expression;
    
    class AddExpression : AdditiveExpression
    {
        pattern
        {
            option leftRecursive;
            a:Expression "+" b:Expression
        }
        
        method Get()
        {
            return this.a.Get...() + this.b.Get...();
        }
    }
    
    class SubExpression : AdditiveExpression
    {
        pattern
        {
            option leftRecursive;
            a:Expression "-" b:Expression
        }
        
        method Get()
        {
            return this.a.Get...() - this.b.Get...();
        }
    }

    precedence AdditiveExpression < MultiplicativeExpression;
    
    class EqualityExpression : Expression
    {
        pattern
        {
            option leftRecursive;
            a:Expression "==" b:Expression
        }
        
        method Get()
        {
            return this.a.Get...() == this.b.Get...();
        }
    }

    precedence EqualityExpression < AdditiveExpression;

    ///////////////////////////
    // FUNCTIONS AND LAMBDAS //
    ///////////////////////////

    class FunctionCall : Expression
    {
        pattern
        {
            name:Name parameters:(Expression)*
        }

        method Get()
        {
            parameterValues = [];
            for(param in this.parameters) {
                parameterValues.Add(param.Get...());
            }
            parameterValues = parameterValues.ToArray();

            // A "function call" with no parameters is just a variable.
            if(parameterValues.Length == 0) {
                if(scope.Parent.names.ContainsKey(this.name.name)) {
                    _returnValue = scope.Parent.names[this.name.name];
                } else {
                    refParams = null;
                    _returnValue = Katahdin.CodeTree.CallNode.Call(
                        globals.names[this.name.name],
                        parameterValues,
                        true,
                        refParams);
                    
                    if (refParams != null)
                    {
                        for (n = 0; n < this.parameters.Count; n++)
                        {
                            if (refParams[n])
                                this.parameters[n].Set...(parameterValues[n]);
                        }
                    }
                }
                
            }
            else {
                // Please don't actually call this, everything blows up
                refParams = null;
                _returnValue = Katahdin.CodeTree.CallNode.Call(
                    globals.names[this.name.name],
                    parameterValues,
                    true,
                    refParams);
                
                if (refParams != null)
                {
                    for (n = 0; n < this.parameters.Count; n++)
                    {
                        if (refParams[n])
                            this.parameters[n].Set...(parameterValues[n]);
                    }
                }
            }
            return _returnValue;
        }
    }

    class LambdaStatement : Expression
    {
        pattern
        {
            param:Name "->" expr:Expression
        }

        method Get()
        {
           return this.expr.Get...();
        }

        method Call(parameters)
        {
            scope.names[this.param.name] = parameters[0];
            return this.expr.Get();
        }
    }
    
    class FunctionStatement : Statement
    {
        pattern
        {
            functionName:Name "=" expression:Expression ";"
        }
        
        method Call(parameters)
        {
            if(this.expression is globals.Fl.LambdaStatement) {
                // We invoke this lambda with the parameters
                return this.expression.Call...(parameters);
            } else {
                // Nice and easy, just return what it is
                return this.expression.Get...();
            }
        }

        method Run()
        {
            globals.names[this.functionName.name] = this;
        }
    }

    class PrintStatement : Statement
    {
        pattern
        {
            "print" str:StringExpression ";"
        }
        
        method Run()
        {
            print this.str.Get...();
        }
    }

    class TopLevelStatement
    {
        pattern
        {
            statement:Statement
        }
        
        method Parsed()
        {
            this.statement.Run...();
        }
    }
    
    class Program
    {
        pattern
        {
            statements:TopLevelStatement*
        }
    }
}

class FlStatement : Statement
{
    pattern
    {
        "fl" "{" Fl.Program "}"
    }

    method Run()
    {
    }
}
